# structure inspired by MongoKit, however alot simpler (and supporting
# python3)

from bson import InvalidDocument
from pymongo.errors import DuplicateKeyError

from datetime import datetime


class DocumentProperties(type):
    """
    Document metaclass for acquiring the collection handler automatically.
    def __new__(cls, name, parents, dct):
        if '__collection__' in dct:
            # get the collection name and set the handler from the db
            dct['collection'] = dct['db'][[dct['__collection__']]]
        return super(DocumentProperties, cls).__new__(cls, name, parents, dct)
    def __new__(cls, name, parents, d):
        # auto_generating fields..
        if 'fields' in d:
            accessors = {}
            prefixs = ["get_", "set_", "del_"]
            # get custom defined getters, setters and delers
            for k in d.keys():
                v = d[k]
                for i in range(3):
                    if k.startswith(prefixs[i]):
                        accessors.setdefault(k[4:], [None, None, None])[i] = v
            # add fields to be autogenerated
            d['fields'].append('created_at')
            d['fields'].append('updated_at')
            for field in d['fields']:
                if field in accessors.keys():
                    continue
                accessors[field] = [None, None, None]
            for name, (getter, setter, deler) in accessors.items():
                if getter is None:
                    getter = lambda self, name=name: self._content[name] if \
                            name in self._content else None
                if setter is None:
                    setter = \
                        lambda self,v,name=name:self._content.update({name:v})
                d[name] = property(getter, setter, deler, "")
            # add the id by hand, considering that it should not have a setter
            # nor a deler
            d['id'] = property(
                lambda self: self._content['_id'] if '_id' in self._content \
                    else None,
                None, None, "")
        return super(DocumentProperties, cls).__new__(cls, name, parents, d)
    """

    def __init__(self, name, bases, d):
        type.__init__(self, name, bases, d)
        # auto_generating fields..
        if 'fields' in d:
            accessors = {}
            prefixs = ["get_", "set_", "del_"]
            # get custom defined getters, setters and delers
            for k in d.keys():
                v = getattr(self, k)
                for i in range(3):
                    if k.startswith(prefixs[i]):
                        accessors.setdefault(k[4:], [None, None, None])[i] = v
            # add fields to be autogenerated
            d['fields'].append('created_at')
            d['fields'].append('updated_at')
            for field in d['fields']:
                if field in accessors.keys():
                    continue
                accessors[field] = [None, None, None]
            for name, (getter, setter, deler) in accessors.items():
                if getter is None:
                    getter = lambda self, name=name: self._content[name] if \
                            name in self._content else None
                if setter is None:
                    setter = \
                        lambda self,v,name=name:self._content.update({name:v})
                setattr(self, name, property(getter, setter, deler, ""))
            # add the id by hand, considering that it should not have a setter
            # nor a deler
            setattr(self, 'id', property(
                lambda self: self._content['_id'] if '_id' in self._content \
                    else None,
                None, None, ""))


class Document(object, metaclass=DocumentProperties):
    '''
    Base document class/interface for pymongo

    Methods/attributes to be overridden by child classes are:
        :fields - fields for which we should autogenerate properties for ease
            of access. To define custom behavior for setters and/or getters,
            simply define a get_{attribute_name} or set_{attribute_name} method
            and this will be passed as property
        :defaults - dictionary containing the default value for the document
            fields declared above.
        :required_fields - states which fields are required
        :validators - dictionary containing:
                {field_name: [validator,error_msg]}
            these two attributes should be overriden if using the document
            class validation, which is not being used as of now, considering
            that we are using wtforms validation already)
        :from_form - used to parse form_data into the object

    Methods supplied:
        :get_by_id - static method used for retrieving a document by it's id
        :validate - validates fields based on the required_fields and
            validators class attributes. not in use right now, as per the
            above

        :insert - tries to insert a new document in the db
        :update - updates an already existing document
        :__str__
        :__eq__
        :__ne__
    '''
    collection = None
    fields = []
    defaults = {}
    required_fields = []
    validators = {}

    def __init__(self, content):
        self._content = content

    @staticmethod
    def from_form(form_data):
        return NotImplemented

    @classmethod
    def get_by_id(cls, doc_id):
        return cls(cls.collection.find_one({'_id': doc_id}))

    @classmethod
    def get_all(cls):
        # returns a cursor, not instances of documents as it is faster and we
        # we'll use this to pass to the admin templates
        return cls.collection.find()

    def validate(self):
        # validates existence of fields first
        if self.required_fields is not None:
            for field in self.required_fields:
                if field not in self._content:
                    raise InvalidDocument("Campo necessário '{}' não existe".\
                            format(field))
        # apply actual validators
        if self.validators is not None:
            for field in self.validators:
                if not self.validators[field][0](self._content[field]):
                    raise InvalidDocument(self.validators[field][1])

    def get_id(self):
        return str(self._content['_id'])

    def insert(self):
        # set timestamps for all
        d = datetime.utcnow()
        for field in ('created_at', 'updated_at'):
            setattr(self, field, d)
        self.collection.insert_one(self._content)

    def update(self):
        self._content['updated_at'] = datetime.utcnow()
        self.collection.replace_one({'_id': self.get_id()}, self._content)

    def set_defaults(self):
        for field in self.fields:
            if getattr(self, field) in (None, [], {}):
                if field in self.defaults:
                    setattr(self, field, self.defaults[field])

    def __str__(self):
        return str(self._content)

    def __eq__(self, other):
        '''
        Compares two objects by their id's
        '''
        if isinstance(other, User):
            return self.get_id() == other.get_id()
        return NotImplemented

    def __ne__(self, other):
        '''
        Inequality comparator
        '''
        equal = self.__eq__(other)
        if equal is NotImplemented:
            return NotImplemented
        return not equal
